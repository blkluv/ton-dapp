#pragma version >=0.2.0;

#include "asm/helpers.func";
#include "op_codes.func";
#include "magic_constants.func";
#include "storage.func";

#include "messages.func";
#include "get_methods.func";
#include "admin_methods.func";


(slice, int) parse_in_msg(cell in_msg_full_cell) inline {
    slice cs = in_msg_full_cell.begin_parse();
    int flags = cs~load_uint(4);

    slice sender_address = cs~load_msg_addr();

    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = cs~load_coins(); ;; we use message fwd_fee for estimation of forward_payload costs

    return (sender_address, fwd_fee);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    (slice message_from, int fwd_fee) = parse_in_msg(in_msg_full);

    ;; TODO: Allow multiple assets
    ;; handle internal messages
    (int mode,
            slice nft_address,
            slice deployer_address,
            slice buyer,
            cell sell_config,
            cell price_config) = load_data();


    ;; uninited mode, wait for nft
    if (mode == 0) {
        if (equal_slices(message_from, deployer_address)) {
            if (slice_bits(in_msg_body) >= 32) {
                ;; TODO: test admin interface
                ;; try process admin messages
                int op = in_msg_body~load_uint(32);
                int exit_code = process_admin(op, in_msg_body);
                throw(exit_code);
            } else {
                ;; Just allow deploy from deployer
                throw(0);
            }
        }

        ;; It's easy just to drop all messages
        ;; But if we fucked up and got diffrent NFT / FT it'll be burned
        ;; So I want to add transfer of NFT back, not just bounce
        ;;         ;; here we need to drop all messages from all addresses
        ;;         ;; except nft, which we expect
        ;;         throw_unless(228, equal_slices(message_from, nft_address));

        ;; ownership_assigned#05138d91 query_id:uint64 prev_owner:MsgAddress
        ;; forward_payload:(Either Cell ^Cell) = InternalMsgBody;

        int op = in_msg_body~load_uint(32);
        int query_id = in_msg_body~load_uint(64);
        slice prev_owner_address = in_msg_body~load_msg_addr();


        ;; We expect thet previus owner of nft is deployer of this contract
        int deployer_is_prev_owner = equal_slices(prev_owner_address, deployer_address);

        ;; We expect NFT to be the same as in contract
        int is_our_nft = equal_slices(message_from, nft_address);

        ;; We expect op to be ownership_assigned
        int is_ownership_assigned = op == op::nft::ownership_assigned;

        if (is_our_nft & is_ownership_assigned & deployer_is_prev_owner) {
            ;; All good, need to initialize contract
            store_data(1,
                    nft_address,
                    deployer_address,
                    buyer,
                    sell_config,
                    price_config);
            throw(0);
        } elseif (op == op::nft::ownership_assigned) {
            ;; We got not our nft
            ;; Try to send it back

            ;; First we need to validate money
            ;; Is it enough to run previus code, pay for storage, and send message
            int new_fwd_amount = msg_value - little_gas_amount - fwd_fee;
            throw_unless(229, new_fwd_amount > 0);

            send_nft(message_from, prev_owner_address, new_fwd_amount + fwd_fee);
            throw(0);
        } elseif (op == op::ft::transfer_notification) {
            ;; We got Jettons, but current mode is not inited, so just send them back
            ;; TODO: bounce Jettons
            throw(0);
        } else {
            int new_fwd_amount = msg_value - little_gas_amount - fwd_fee;
            throw_unless(229, new_fwd_amount > 0);

            ;; We got some strange stuff, try to send it back, or throw error
            send_message_with_text(message_from, new_fwd_amount + fwd_fee, "Error", 2);
            throw(0);
        }
    } elseif (mode == 1) { ;; Seller is inited
        ;; Change settings & admin control

        if (equal_slices(message_from, deployer_address)) {
            ;; Here we can buy NFT or change settings
            int op = in_msg_body~load_uint(32);

            ;; Change price
            ;; TODO: add tests
            ;; TODO: add cancel
            if (op == op::seller::change_price) {
                cell new_price_config = in_msg_body~load_ref();
                store_data(1,
                        nft_address,
                        deployer_address,
                        buyer,
                        sell_config,
                        new_price_config);
                throw(0);
            }

            ;; Here we can allow admin commands
            ;; Because seller can transfer NFT back
            ;; Need to think of limitations on sending transfer messages to assets inside contract
            throw(179);
            ;;             else { ;; or process admin stuff
            ;;                 int exit_code = process_admin(op, in_msg_body);
            ;;                 throw(exit_code);
            ;;             }
        } else {
            ;; Try to buy
            (int is_ton, int price) = parse_price_config(price_config);
            (int marketplace_numerator,
                    int marketplace_denominator,
                    int royalty_numerator,
                    int royalty_denominator,
                    slice royalty_destanation) = parse_sell_config(sell_config);
            int market_fee = 0;
            int royalty_fee = 0;

            if ((marketplace_numerator > 0) & (marketplace_denominator > 0)) {
                market_fee = min(price, muldiv(price, marketplace_numerator, marketplace_denominator));
            }

            price -= market_fee;

            if ((royalty_numerator > 0) & (royalty_denominator > 0) & (price > 0)) {
                royalty_fee = min(price, muldiv(price, royalty_numerator, royalty_denominator));
            }

            price -= royalty_fee;

            if (is_ton == 1) {
                ;; Buy with TON
                if (msg_value - price - royalty_fee - market_fee - very_little_gas_amount <= 0) {
                    ;; Send money back
                    int new_fwd_amount = msg_value - fwd_fee - little_gas_amount;
                    throw_unless(229, new_fwd_amount > 0);
                    send_message_with_text(message_from, new_fwd_amount + fwd_fee, "No funds ðŸŒš", 2);
                } else {
                    send_message_with_text(marketplace, market_fee, "Market fee, sir ðŸ¤Œ", 1);
                    send_message_with_text(royalty_destanation, royalty_fee, "Hey, your royalty, sir ðŸ¤Œ", 1);

                    tuple wow = unsafe_to_tuple(["ðŸ¤­", "ðŸ˜±", "ðŸ¥³", "ðŸ‘€", "ðŸ«¶"]);
                    int wow_num = rand(5);
                    send_message_with_text(deployer_address, price, wow.at(wow_num), 1);

                    raw_reserve(100000, 0); ;; save little ammount
                    send_nft(nft_address, message_from, -1); ;; transfer nft

                    store_data(2, ;; change mode to 2 (nft was bought)
                            nft_address,
                            deployer_address,
                            message_from, ;; change who was bought nft
                            sell_config,
                            price_config);
                }

                throw(0);
            } else {
                ;; TODO: buy with jetton
                throw(0);
            }

        }

    }

    int op = in_msg_body~load_uint(32);

    if (mode == 2) { ;; NFT was bought
        if (equal_slices(message_from, buyer)) {
            if (op == op::seller::send_nft) { ;; send nft one more time
                raw_reserve(100000, 0); ;; save little ammount
                send_nft(nft_address, message_from, -1); ;; transfer nft

                throw(0);
            } else { ;; or process admin stuff
                int exit_code = process_admin(op, in_msg_body);
                throw(exit_code);
            }
        } else {
            throw(179);
        }
    } elseif (mode == 3) { ;; Seller was canceled
        if (equal_slices(message_from, deployer_address)) {
            if (op == op::seller::send_nft) { ;; send nft one more time
                raw_reserve(100000, 0); ;; save little ammount
                send_nft(nft_address, message_from, -1); ;; transfer nft

                throw(0);
            } else { ;; or process admin stuff
                int exit_code = process_admin(op, in_msg_body);
                throw(exit_code);
            }
        }else {
            throw(179);
        }
    }

}

() recv_external(slice in_msg_body) impure {
    ;; handle external messages
}
